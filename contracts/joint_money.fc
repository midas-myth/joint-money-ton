#include "imports/stdlib.fc";
#include "constants.fc";

const int op::create_group = 1;
const int op::deposit = 2;
const int op::withdraw = 3;

(int, slice, int, cell) parse_group(slice body) {
    int id = body~load_uint(GROUP_MAP_KEY_SIZE_BITS);
    slice name = body~load_bits(GROUP_NAME_SIZE_BITS);
    int balance = body~load_grams();
    cell members = body~load_maybe_ref();
    body.end_parse();

    return (id, name, balance, members);
}

slice serialize_group(int id, slice name, int balance, cell members) {
    ~strdump("serialize_group");
    return begin_cell()
        .store_uint(id, GROUP_MAP_KEY_SIZE_BITS)
        .store_slice(name)
        .store_grams(balance)
        .store_maybe_ref(members)
        .end_cell()
        .begin_parse();
}


slice get_group(int id) {
    ~strdump("get_group");
    slice data_reader = get_data().begin_parse();
    ~strdump("Loaded data reader");
    int group_count = data_reader~load_uint(GROUP_MAP_KEY_SIZE_BITS);
    ~strdump("Loaded group count");
    cell group_map = data_reader~load_dict();
    ~strdump("Loaded group map");
    data_reader.end_parse();
    ~strdump("Finished loading store");

    (slice group, int key) = group_map.udict_get?(GROUP_MAP_KEY_SIZE_BITS, id);

    return group;
}

() set_group(int id, slice group) impure {
    ~strdump("set_group");
    slice data_reader = get_data().begin_parse();
    int group_count = data_reader~load_uint(GROUP_MAP_KEY_SIZE_BITS);
    ~strdump("Loaded group count");
    cell group_map = data_reader~load_dict();
    ~strdump("Loaded group map");
    data_reader.end_parse();

    (slice existing_group, int key) = group_map.udict_get?(GROUP_MAP_KEY_SIZE_BITS, id);

    if (null?(existing_group)) {
        ~strdump("New group");
        group_count += 1;
    }

    ~strdump("group_map setting new group");
    group_map~udict_set(GROUP_MAP_KEY_SIZE_BITS, id, group);
    ~strdump("group_map set with new group");
    set_data(
        begin_cell()
            .store_uint(group_count, GROUP_MAP_KEY_SIZE_BITS)
            .store_dict(group_map)
            .end_cell()
    );
    ~strdump("set_data done");
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    ;;   src:MsgAddress dest:MsgAddressInt 
    ;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    ;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

    slice msg_reader = in_msg_full.begin_parse();
    ;; bit prefix, instant hypercube routing, bounce flag, bounced flag
    int flags = msg_reader~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice src = msg_reader~load_msg_addr();
    slice dest = msg_reader~load_msg_addr();
    src~dump();
    dest~dump();

    if (equal_slices(src, my_address())) {
        ~strdump("Weird, I am the source");
    }

    if (equal_slices(dest, my_address())) {
        ~strdump("I am the destination");
    }

    int value = msg_reader~load_coins();
    value~dump();
    cell currency_collection = msg_reader~load_dict();

    int ihr_fee = msg_reader~load_grams();
    ~strdump("ihr_fee");
    ~dump(ihr_fee);
    int fwd_fee = msg_reader~load_grams();
    ~strdump("fwd_fee");
    ~dump(fwd_fee);
    int created_lt = msg_reader~load_uint(64);
    ~strdump("created_lt");
    ~dump(created_lt);
    int created_at = msg_reader~load_uint(32);
    ~strdump("created_at");
    ~dump(created_at);


    int op = in_msg_body~load_uint(32);
    ~dump([op::create_group, op]);

    int query_id = in_msg_body~load_uint(64);
    query_id~dump();

    if (op == op::create_group) {
        ~strdump("op::create_group");
        slice data_reader = get_data().begin_parse();
        int group_count = data_reader~load_uint(GROUP_MAP_KEY_SIZE_BITS);
        int new_group_id = group_count + 1;
        ~strdump("new_group_id");
        ~dump(new_group_id);

        cell name_cell = in_msg_body~load_ref();
        ~strdump("name_cell loaded");
        slice name_reader = name_cell.begin_parse();
        ~strdump("name_reader");
        slice name = name_reader~load_bits(GROUP_NAME_SIZE_BITS);
        ~strdump("name read");
        name_reader.end_parse();
        if (name.slice_empty?()) {
            ~strdump("Name is empty");
            throw(0xffff);
        }
        ~strdump("name");
        ~dump(name);
        int balance = in_msg_body~load_grams();
        ~strdump("balance");
        ~dump(balance);
        cell members = in_msg_body~load_maybe_ref();
        ~strdump("members");
        ~dump(members);
        in_msg_body.end_parse();
        ~strdump("in_msg_body parsed");

        ;; int id, slice name, int balance, cell members
        slice new_group = serialize_group(new_group_id, name, balance, members);
        ~strdump("new_group");

        set_group(
            new_group_id,
            new_group   
        );
        ~strdump("set_group done");


        return ();
    }
    elseif (op == op::deposit) {
        return ();
    }
    elseif (op == op::withdraw) {
        return ();
    }

    throw(0xffff);
}


(int, slice, int) get_group_by_id(int id) method_id {
    ~strdump("get_group_by_id");
    slice group = get_group(id);

    if (null?(group)) {
        ~strdump("Group not found");
        return (0, "", 0);
    }

    (int group_id, slice group_name, int group_balance, cell group_members) = parse_group(group);

 
    return (group_id, group_name, group_balance);
}

